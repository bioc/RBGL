%
% NOTE -- ONLY EDIT RBGL.Rnw!!!
% RBGL.tex file will get overwritten.
%
%\VignetteIndexEntry{RBGL Overview}
%\VignetteDepends{graph}
%\VignetteKeywords{Graphs}
%\VignettePackage{RBGL}

\documentclass[12pt]{article}

\usepackage{amsmath,pstricks}
\usepackage[authoryear,round]{natbib}
\usepackage{hyperref}


\textwidth=6.2in
\textheight=8.5in
%\parskip=.3cm
\oddsidemargin=.1in
\evensidemargin=.1in
\headheight=-.3in

\newcommand{\scscst}{\scriptscriptstyle}
\newcommand{\scst}{\scriptstyle}

%\setkeys{Gin}{width=0.55\textwidth}


\bibliographystyle{plainnat} 
 
\begin{document}

\title{{\it RBGL}: R interface to boost graph library}
\author{VJ Carey {\tt stvjc@channing.harvard.edu}}
\maketitle

\begin{quotation} {\it Summary}.  
An interface from R to the Boost Graph Library (BGL, an alternative
to STL programming for mathematical graph objects) is described.
{\it This 2003 update employs the {\em graph} class of Bioconductor.}
\end{quotation}

\tableofcontents

\section{Working with the Bioconductor {\tt graph} class}
An example object
representing file dependencies is included, as shown
in Figure \ref{fdpic}.  
<<showFileDep>>=
library(RBGL)
data(FileDep)
print(FileDep)
@
\begin{figure}
%  fig=TRUE
%  z <- plot(FileDep)
@
\includegraphics{filedep}
\caption{File dependency digraph example from Boost library.}
\label{fdpic}
\end{figure}

\section{Algorithms supported by RBGL}
\subsection{Topological sort}

The {\tt tsort} function will return the indices of vertices
in topological sort order:
<<tsortDemo>>=
ts <- tsort(FileDep)
print(nodes(FileDep)[ts + 1])
@
Note that if the input graph is not a DAG, BGL {\tt topological\_sort}
will check this and throw 'not a dag'.  This is crudely captured
in the interface (a message is written to the console and zeroes are returned).
\begin{verbatim}
#FD2 <- FileDep
# now introduce a cycle
#FD2@edgeL[["bar_cpp"]]$edges <- c(8,1)
#tsort(FD2)
\end{verbatim}

\subsection{Kruskal's minimum spanning tree}

Function {\tt mstree.kruskal} just returns a list of edges, weights and nodes
determining the minimum spanning tree (MST) by
Kruskal's algorithm.
<<KMSTdemo>>=
km <- fromGXL(file(system.file("GXL/kmstEx.gxl", package="graph")))
print(mstree.kruskal(km))
@
\begin{figure}
\includegraphics{RBGL-004}
\caption{Kruskal MST example from Boost library.}
\label{mspic}
\end{figure}

@
\subsection{Depth first search}
The {\tt dfs} function returns a list of node indices by
discovery and finish order.
<<DFSdemo>>=
df <- fromGXL(file(system.file("XML/dfsex.gxl", package="RBGL")))
print(o <- dfs(df))
@
\begin{figure}
% z <- plot(df)
\includegraphics{RBGL-005}
\caption{DFS example from Boost library.}
\label{dfspic}
\end{figure}
@
Here is the list of nodes in DFS discovery order.
<<>>=
print(nodes(df)[o$discovered])
@

@
\subsection{Breadth first search}
The {\tt bfs} function returns a vector of node indices
for a breadth-first search (BFS) starting at the
node indexed by {\tt init.node}.
<<BFSdemo>>=
bf <- fromGXL(file(system.file("XML/bfsex.gxl", package="RBGL")))
bf@edgemode <- "undirected"
print(o <- bfs(bf,nodes(bf)[2]))
# currently 8/03 bf non reciprocal and validity check fails so plot fails
<<fig=TRUE>>=
#z <- plot(bf)
@
The nodes in BFS order starting with the second node are
<<>>=
print(nodes(bf)[o])
@

@
\subsection{Dijkstra's shortest paths}
<<dijkdemo>>=
dd <- fromGXL(file(system.file("XML/dijkex.gxl", package="RBGL")))
print( dijkstra.sp(dd) )
<<dijkdemo2>>=
ospf <- fromGXL(file(system.file("XML/ospf.gxl",package="RBGL")))
@
\begin{figure}
@
\setkeys{Gin}{width=0.95\textwidth}
\includegraphics{RBGL-011}
\caption{Network example from BGL.} 
\end{figure}
<<dijkdemo2b>>=
dijkstra.sp(ospf,nodes(ospf)[6])
sp.between(ospf, "RT6", "RT1")
dd <- fromGXL(file(system.file("XML/dijkex.gxl", package="RBGL")))
print( dijkstra.sp(dd) )
@
\subsection{Connected components }
<<conndemo>>=
km <- fromGXL(file(system.file("GXL/kmstEx.gxl",package="graph")))
km@nodes <- c(km@nodes,"F","G","H")
km@edgeL$F <- list(edges=numeric(0))
km@edgeL$G <- list(edges=8, weights=1)
km@edgeL$H <- list(edges=7, weights=1)
km@edgemode <- "undirected"
if (length(agrep("solaris", version[["platform"]]))==0)
print(connectedComp(ugraph(km))) else
print("not running on solaris, use windows or linux")
@
\subsection{Strongly connected components }
<<sconndemo>>=
km <- fromGXL(file(system.file("GXL/kmstEx.gxl",package="graph")))
km@nodes <- c(km@nodes,"F","G","H")
km@edgeL$F <- list(edges=numeric(0))
km@edgeL$G <- list(edges=8, weights=1)
km@edgeL$H <- list(edges=7, weights=1)
km@edgemode <- "directed"
print(strongComp(km))
@
\subsection{Edge connectivity and minimum disconnecting set}

<<econndemo>>=
coex <- fromGXL(file(system.file("XML/conn.gxl",package="RBGL")))
dcoex <- coex
dcoex@edgemode <- "directed"
udcoex <- ugraph(dcoex)
@
\begin{figure}
\includegraphics{RBGL-016}
\caption{Edge connectivity example.}
\end{figure}
<<econnDemo2>>=
if (length(agrep("solaris", version[["platform"]]))==0)
print(edgeConnectivity(coex)) else
print("not running on solaris, use windows or linux")
@
\end{document}


